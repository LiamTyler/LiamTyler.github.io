<!DOCTYPE HTML>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Liam Tyler</title>
    <link rel='stylesheet' type='text/css' href='/styles/styles.css'>
    <link href="/styles/prism.css" rel="stylesheet" />
    <script src='/scripts/jquery-3.2.1.js'></script>
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon"/>

<!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145372343-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-145372343-1');
    </script>
  </head>
  <body>
    <div class="navbar">
      <nav>
        <ul>
          <div class="floating">
            <li id="LT-header">Liam Tyler<p>Software Developer</p></li>
            <li><a href="/index.html">Home</a></li>
            <li><a href="/about/index.html">About</a></li>
            <li><a href="/portfolio/index.html">Portfolio</a></li>
            <li><a href="/work/index.html">Work & Research</a></li>
          </div>
        </ul>
      </nav>
    </div>
    <script src="/scripts/prism.js"></script>
    <div id="projects">
      <h1 class="centerText">Progression</h1>
      <hr>

      <h2>Description</h2>
      <p>Progression is a 3D game engine written in C++ for Linux and Windows. It originally started out as an simple OpenGL renderer for class projects, but it now features a Vulkan renderer, Lua scripting, skeletal animation, asset serialization, and more. It is my largest project to date, even though I keep rewriting it as I learn more and gain more experience with C++ and graphics.</p>

      <h2>Code</h2>
      <p>Code from this project can be found on Github <a href="https://github.com/LiamTyler/Progression">here</a></p>

      <h2>Features</h2>
      <h5>Note: for SSAO, deferred rendering, and normal mapping I partnered up with <a href="https://sites.google.com/umn.edu/zachsportfolio/home?fbclid=IwAR1FnQC03IqJdBMhxeNZn87i8_SSe2-Nqb-QXauz415a9FeM0b06g5vd0L0">Zach Chavis</a> for them as part of a project</h5>
      
      <h4>Screen Space Ambient Occlusion (SSAO)</h4>
      <p>We took the approach described in <a href="https://learnopengl.com/Advanced-Lighting/SSAO">this</a> tutorial. This method randomly samples many nearby points for each pixel, and return which fraction of those samples were occluded by other nearby geometry. This can be seen in the following image:</p>
      <div class="centerText">
        <img class="capWidth" src="ssao_hemisphere.png">
        <p>Two example of the SSAO hemisphere for two points. Image from the tutorial above.</p>
      </div>
      <p>To sample random points within this hemisphere surrounding each pixel, we need to use random offsets. Since it would be impracticle to generate or store random offsets for each possible orientation of the hemisphere, we instead create a buffer of random offsets in the tangent space. </p>
      
      <div class="centerText">
        <div style="float: left; width: 50%; padding: 5px;">
          <img src="no_ao_sponza.png" style="width:100%">
        </div>
        <div style="float: left; width: 50%; padding: 5px;">
          <img src="ao_sponza.png" style="width:100%">
        </div>
        <p>Sponza without SSAO (left) and Sponza with SSAO (right).</p>
        <img class="capWidth" src="AO.png">
        <p>The ambient occlusion texture.</p>
      </div>
      
      <br>
      <h4>Deferred Rendering</h4>
      <p>While I had written a tiled-deferred renderer in OpenGL, current Vulkan renderer is just regular deferred rendering without even light volumes currently. Tiled deferred or F+ is on the docket. Only just started trying to consider the GBuffer size and reduce it, but the current GBuffer looks like this:</p>
      <ul>
        <li><strong>Positions: </strong>RGBA32_FLOAT</li>
        <li><strong>Normals: </strong>RGBA8_UNORM (compressed using 24-bit octahedron encoding)</li>
        <li><strong>Diffuse and Specular Colors: </strong>RGBA16_UINT (upper 8 bits of RGB are diffuse color, lower 8 are specular, and the alpha component is the 16 bit specular exponent)</li>
        <li><strong>Ambient Occlusion: </strong>R8_UNORM</li>
        <li><strong>Depth: </strong>32 bit</li>
      </ul>
      <p>While positions and normals do not need the alpha channel, my GPUs do not support RGB textures with optimal tiling. Initially normals were RGBA32_FLOAT, the diffuse and specular were RGBA_UNORM and RGBA16_FLOAT respectively. With each change to the gbuffer we saw the following timings:</p>
      <img class="capWidth" src="gbuffer_timings.png">
      <p>Sponza timings with 4 lights in 1080p on my RTX 2080. Yes, the SSAO pass is very unoptimized currently.</p>
      <p>I am currently trying to figure out if 16 bit positions are okay, and play around with what I could put in the alpha channel instead of it being unused. I also want to try getting rid of the position buffer altogether and just recover it via the depth buffer.</p>
      
      <br>
      <h4>Normal Mapping</h4>
      <p>The VBO stores the normals and tangents, but not the bitangents since those are calculated in the shader. The TBN matrix which transforms vectors from tangents space to world space is calculated with the following pseudocode:</p>
      <pre><code class="language-glsl">vec3 worldT = normalize( modelMatrix * inTangent );
vec3 worldN = normalize( inverse( transpose( modelMatrix ) ) * inNormal );
vec3 worldB = cross( worldN, worldT );
TBN         = mat3( worldT, worldB, worldN );</code></pre>

      <p>All the blogs and tutorials we saw online multiply both the tangent and normal by just the model matrix, but we are pretty sure that since the normal does not lie on the geometry surface, just multiplying by the model matrix would skew the result for non-uniform scaling. The tangent and bitangent lie along the surface though and do not need the inverse transpose. We then just look up the normal map value, normalize to [-1, 1] and apply the matrix:</p>
      <code class="language-glsl">
      vec3 n = texture( normalMap, texCoord );
      n      = normalize( n * 2 - 1 );
      n      = normalize( TBN * n );
      </code>
      
      <br>
      <h4>Profiling and RenderDoc Integration</h4>
      <p></p>

      <br>
      <h2>Videos</h2>
      <div class="center">
      <iframe width="560" height="315" src="https://www.youtube.com/embed/Du04-9DlrCA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      <p>A short demo highlighting some of the more recent rendering features</p>
      </div>
      <br>
      <!--
      <h2>Images:</h2>
      <div class="centerText">
        <img class="capWidth" src="robots_bloom.png">
        <p>Robots collecting each of the five lights. Robots plan path using TTC algorithm.</p>
        <hr>
        <hr>
      </div>
      -->
  </body>
</html>
