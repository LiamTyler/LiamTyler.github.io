<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Liam&#39;s Graphics Blog</title>
    <link>https://liamtyler.github.io/posts/</link>
    <description>Recent content in Posts on Liam&#39;s Graphics Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://liamtyler.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>In-depth Analysis of Octahedral Encoded Normals</title>
      <link>https://liamtyler.github.io/posts/octahedral_analysis/</link>
      <pubDate>Thu, 30 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://liamtyler.github.io/posts/octahedral_analysis/</guid>
      <description>Octahedron encoding (also called octahedral encoding) is a very popular way to encode normals. It&amp;rsquo;s fast to encode, very fast to decode, has near uniform mapping, and has low error. While writing my last post on meshlet compression, I spent a lot of time looking at that final aspect, the low error. I had three questions I wanted answered: what is the error quantitatively, can that be used to help select the quantization level, and can any further compression be applied?</description>
    </item>
    <item>
      <title>Basic Meshlet Compression</title>
      <link>https://liamtyler.github.io/posts/meshlet_compression/</link>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://liamtyler.github.io/posts/meshlet_compression/</guid>
      <description>Mesh shaders have become increasingly popular over the last few years with UE5&amp;rsquo;s Nanite, and games like Alan Wake II. With that popularity came a wave of articles discussing how to write basic mesh shaders, and the pros and cons of different vertex and triangle limits. Those are all great, but I noticed there aren&amp;rsquo;t that many sources discussing how you might compress meshlet vertex and triangle data. The sources that do discuss the compression often gloss over details, whether it&amp;rsquo;s implementation details, how likely people are to notice the quantization, runtime performance, or discussion of alternative methods.</description>
    </item>
    <item>
      <title>A Poor Man&#39;s Render Graph</title>
      <link>https://liamtyler.github.io/posts/task_graph/</link>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://liamtyler.github.io/posts/task_graph/</guid>
      <description>Render Graphs, or &amp;ldquo;Task Graphs,&amp;rdquo; rapidly became the standard in the industry ever since Yuriy O&amp;rsquo;Donnell&amp;rsquo;s 2017 GDC presentation on Frostbite&amp;rsquo;s FrameGraph. They provide many benefits, like handling all of the synchronization barriers and resource transitions, reordering tasks for increased performance, reducing memory usage via resource aliasing, and the list goes on for miles. Theyâ€™re nearly mandatory for large projects these days, given how verbose and error-prone these things would be if done manually with modern APIs like Vulkan and DX12.</description>
    </item>
    <item>
      <title>Asset Pipelines Part 1</title>
      <link>https://liamtyler.github.io/posts/asset_pipeline_part_1/</link>
      <pubDate>Sun, 07 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://liamtyler.github.io/posts/asset_pipeline_part_1/</guid>
      <description>Asset pipelines are one of the pieces of game development I don&amp;rsquo;t see people talk about very often. The main concepts are often introduced and chatted about theoretically, sure: &amp;ldquo;convert your assets into binary packages, compress them, and load them at runtime,&amp;rdquo; but rarely do I find people chatting about the implementation details. It always strikes me as a little odd, because I&amp;rsquo;d argue it has the single biggest impact on development.</description>
    </item>
    <item>
      <title>Generating Height Maps From Normal Maps</title>
      <link>https://liamtyler.github.io/posts/normal-to-height/</link>
      <pubDate>Fri, 05 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://liamtyler.github.io/posts/normal-to-height/</guid>
      <description>In this post, I want to explain how to take a normal map and generate its corresponding height map (also called displacement map). There are multiple ways to achieve this, but the one I&amp;rsquo;ll be covering in this post is the method that Danny Chan presented in Advances in Real Time Rendering at Siggraph 2018 (link here, page 16). It&amp;rsquo;s also the same method that the Call of Duty engine still uses today to generate the vast majority of its height maps.</description>
    </item>
  </channel>
</rss>
